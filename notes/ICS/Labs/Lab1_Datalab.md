# DataLab

## 关于Linux的必要指令

上传文件：`scp [本地文件] ubuntu@[ip]:[文件夹]`

下载文件（到当前目录）：`scp ubuntu@[ip]:/home/...`

当前工作目录：`pwd`

当前文件夹列表：`ls`

进入`xxx`文件夹：`cd xxx`

返回上级文件夹：`cd ..`

创建文件夹：`mkdir [NAME]`

创建文件：`touch [NAME]`

删除：`rm [OPTIONS] [NAME]`

- `-r` 递归删除一个目录

- `-f` 强制删除

压缩与解压缩tar文件: `tar [OPTIONS] [NAME]`（常用：`tar -xvf [TAR] -C [PATH]`）

- `-x` 解压

- `-c` 选择多个目录/文件进行打包

- `-f [PACAGE_NAME]` 指定打包后文件名

- `-z` 压缩与解压缩tar.gz文件

- `-C [TARGET_DIR]` 指导解压目录

编译c文件：`gcc [SRC] –o [DEST]`

---

## 写前须知：

### 1.作业说明

北京大学的DataLab每年的出入都不小，但比较难的题在网上找一找总是有的。

所有的代码均在文件`bits.c`中完成，而`Btest`（`btest.c`的编译结果）用于测试你的程序。每当你改动你的代码后，都需要重新编译文件：

```bash
make
```

`btest`：用于测试你的函数是否正确。仅在一个小的测试集上进行测试，不能完全保证你的函数是正确的。

```bash
# 编译并运行
make && ./btest
# 对某个函数进行单元测试
make && ./btest -f bitXnor
# 对某个函数进行单元测试，且指定测试用例，以 -1 指定第一个参数，依次类推
make && ./btest -f bitXnor -1 7 -2 0xf
```

注意，这里的 `make` 是必需的，每当你修改了 `bits.c`，都需要重新编译。有关编译的更多知识，你会在第七章学习到。

`dlc`：用于检查你的代码是否符合规范。

```bash
# 检查是否符合编码规范
./dlc bits.c
```

`bdd checker`：穷举测试所有可能的输入，完整地检查你的函数是否正确。

```bash
# 对某个函数进行单元测试
./bddcheck/check.pl -f bitXnor
# 检查所有函数
./bddcheck/check.pl
# 检查所有函数，且输出总结信息
./bddcheck/check.pl -g
```

`driver.pl`：用于评分，检查你的函数是否符合规范且正确。

```bash
./driver.pl
```

### 2.辅助工具

要使用辅助工具，你必须先编译：

```bash
make
```

`ishow`：用于显示整数的二进制形式。

```bash
# 显示 -1 的二进制形式
./ishow -1
# Hex = 0xffffffff,       Signed = -1,    Unsigned = 4294967295

# 以 0x 开头，十六进制表示转整数
./ishow 0xffffffff
# Hex = 0xffffffff,       Signed = -1,    Unsigned = 4294967295
```

`fshow`：用于显示浮点数的二进制形式。

```bash
# 带小数点，浮点数转表示
./fshow 12.0
# Floating point value 12
# Bit Representation 0x41400000, sign = 0, exponent = 0x82, fraction = 0x400000
# Normalized.  +1.5000000000 X 2^(3)

# 不带小数点，表示转浮点数
./fshow 12
# Floating point value 1.681558157e-44
# Bit Representation 0x0000000c, sign = 0, exponent = 0x00, fraction = 0x00000c
# Denormalized.  +0.0000014305 X 2^(-126)

# 不带小数点，以 0x 开头，十六进制表示转浮点数
./fshow 0x41400000
# Floating point value 12
# Bit Representation 0x41400000, sign = 0, exponent = 0x82, fraction = 0x400000
# Normalized.  +1.5000000000 X 2^(3)
```

### 3.代码要求

函数中的只能使用`1~255`的整数，不可以使用类似`0xffffffff`的大数；只能使用函数参数和局部变量。

你能使用的运算符有：单目运算符`!`、`~`、`&`、`|`、`^`、`+`、`<<`、`>>`；

不能使用**条件**、**循环**、**分支**语句；不能使用**宏**或声明/使用**额外的函数**；不能使用诸如`&&`、`||`、`-`、`?`的**运算符**；不能使用任何形式的**类型转换**；不能使用除`int`外的数据类型，包括数组、结构体和联合体。

你的机器：使用二进制补码、32位的整数表示、使用算术右移、超出限制会发生不可预测的事情。

对于需要实现浮点运算的问题，编码规则不那么严格。你可以使用循环和条件控制、整数和无符号整数、任意的整数和无符号常量。但是不可以使用任何浮点数据类型、操作或常量。

具体函数见下文：

---

DataLab算是8个Lab最简单的一个，目的是实现如下函数（puzzle）：

整数部分：

| 名称         | 评分  | 最大操作数 | 名称             | 评分  | 最大操作数 |
| ---------- | --- | ----- | -------------- | --- | ----- |
| bitOr      | 1   | 8     | negate         | 2   | 5     |
| upperBits  | 1   | 10    | oneMoreThan    | 2   | 15    |
| fullAdd    | 2   | 20    | ezThreeFourths | 3   | 12    |
| rotateLeft | 3   | 25    | isLess         | 3   | 24    |
| bitParity  | 4   | 20    | satMul2        | 3   | 20    |
| palindrome | 4   | 40    | modThree       | 4   | 60    |

浮点数部分：

| 名称          | 评分  | 最大操作数 |
| ----------- | --- | ----- |
| float_half  | 4   | 30    |
| float_i2f   | 4   | 30    |
| float64_f2i | 4   | 20    |
| float_pwr2  | 4   | 30    |

## bitOr

- 目标：实现`x | y`

- 可用操作：`~`、`&`

- 最大操作数：8

- 评分：1

这个题没什么难度，无非是考察`&`和`|`的关系。

```c
int bitOr(int x, int y) {
  return ~((~x) & (~y));
}
```

## upperBits

- 目标：在32位整数的高n位上补0（0 <= n <= 32）

- 可用操作：`!`、`~`、`&`、`^`、`|`、`+`、`<<`、`>>`

- 最大操作数：10

- 评分：1

本题有一个需要注意的点是`n`可以为0，所以不能直接移动1，而是移动`!!n`。另外DataLab不允许使用`-`，所以用`+(~n + 1)`代替：

```c
int upperBits(int n) {
  return ((!!n) << 31) >> (n + ~1 + 1);
}
```

## fullAdd

- 目标：实现一个4 bits的加法。说人话就是`(x + y) mod 16`（0 <= x, y < 16）

- 可用操作：`~`、`|`、`^`、`&`、`<<`、`>>`

- 最大操作数：20

- 评分：2

本题最恶心人的地方在于不能使用`+`，我们只能使用`^`和`&`模拟求和和进位操作。这个过程是有限步的，因为保留后4位，只需要连续模拟4次求和后答案就已经稳定。

```c
int fullAdd(int x, int y) {
  int res1 = x ^ y;
  int carry1 = (x & y) << 1;
  int res2 = res1 ^ carry1;
  int carry2 = (res1 & carry1) << 1;
  int res3 = res2 ^ carry2;
  int carry3 = (res2 & carry2) << 1;
  int res4 = res3 ^ carry3;
  return res4 & 15;
}
```

## rotateLeft

- 目标：循环左移，即左边的位移到右边

- 可用操作：`!`、`~`、`&`、`^`、`|`、`+`、`<<`、`>>`

- 最大操作数：25

- 评分：3

这个题可能对于写循环写习惯的同学来说不太友好，但是总体不难：通过`&`将对应数位提取出来后移位，然后拼接两部分即可。

```c
int rotateLeft(int x, int n) {
  int res = x << n;
  int window = (1 << n) + (~1 + 1); // 创建提取数位的窗口
  res += ((((window << (32 + ~n + 1)) & x) >> (32 + ~n + 1)) & window);
  return res;
}
```

## bitParity

- 目标：如果`x`（二进制补码）有奇数个0则返回1；反之则返回0。

- 可用操作：`!`、`~`、`&`、`^`、`|`、`+`、`<<`、`>>`

- 最大操作数：20

- 评分：4

这个题都出到这里了显然不可能让我们数一遍1的个数。32位整型中0和1的奇偶性相同，通过异或操作，两个0或1都会被归零。故将x依次相邻2^n (n=1,2,3,4,5)的数位做异或，偶数个0和1均被归零，若为奇数个1则x最后以1结尾，反之则以0结尾：

```c
int bitParity(int x) {
  x = x ^ (x >> 1);
  x = x ^ (x >> 2);
  x = x ^ (x >> 4);
  x = x ^ (x >> 8);
  x = x ^ (x >> 16);
  return x & 1;
}
```

## palindrome

- 目标：判断一个二进制补码是不是回文数

- 可用操作：`!`、`~`、`&`、`^`、`|`、`+`、`<<`、`>>`，可以使用大数。

- 最大操作数：40

- 评分：4

判断回文数最朴素的想法就是：能不能把`x`反转后与原来的`x`比较？

```c
int palindrome(int x) {
  // 逐次对x的每2^n(n=4,3,2,1,0)做交换即可！
  int y = ((x >> 16) & 0x0000ffff) + ((x & 0x0000ffff) << 16);
  y = ((y >> 8) & 0x00ff00ff) + ((y & 0x00ff00ff) << 8);
  y = ((y >> 4) & 0x0f0f0f0f) + ((y & 0x0f0f0f0f) << 4);
  y = ((y >> 2) & 0x33333333) + ((y & 0x33333333) << 2);
  y = ((y >> 1) & 0x55555555) + ((y & 0x55555555) << 1);
  return !(y ^ x);
}
```

## negate

- 目标：返回`-x`

- 可用操作：`!`、`~`、`&`、`^`、`|`、`+`、`<<`、`>>`

- 最大操作数：5

- 评分：2

没有什么技术含量

```c
int negate(int x) {
  return (~x + 1);
}
```

## oneMoreThan

- 目标：比较`y`是否比`x`大一。若是则返回1，否则返回0。

- 可用操作：`!`、`~`、`&`、`^`、`|`、`+`、`<<`、`>>`

- 最大操作数：15

- 评分：2

这道题的坑就是：`x = Tmax, y = Tmin`，即数值溢出。不过比较简单，只需要两个条件：`y == x + 1`且`y != 0x80000000`

```c
int oneMoreThan(int x, int y) {
  return !(((x+1) ^ y) | !(y ^ (1 << 31)));
}
```

其实写成`!((x+1) ^ y) & !!(y ^ (1 << 31));`更加符合逻辑，上述写法是为了减少运算次数()。

## ezThreeFourths

- 目标：

- 可用操作：

- 最大操作数：

- 评分：

## isLess

- 目标：

- 可用操作：

- 最大操作数：

- 评分：

## satMul2

- 目标：

- 可用操作：

- 最大操作数：

- 评分：

## modThree

- 目标：

- 可用操作：

- 最大操作数：

- 评分：

## float_half

- 目标：

- 可用操作：

- 最大操作数：

- 评分：

## float_i2f

- 目标：

- 可用操作：

- 最大操作数：

- 评分：

## float64_f2i

- 目标：

- 可用操作：

- 最大操作数：

- 评分：

## float_pwr2

- 目标：

- 可用操作：

- 最大操作数：

- 评分：
