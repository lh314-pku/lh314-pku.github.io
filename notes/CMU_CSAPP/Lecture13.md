# Lecture13：Linking

## Linking

考虑如下两个文件：

```c
/* main.c */
int sum(int *a, int n);
int array[2] = {1, 2};
int main(){
    int val = sum(array, 2);
    return val;
}
```

```c
/* sum.c */
int sum(int *a, int n){
    int i, s = 0;
    for (i = 0; i < n; i++){
        s += a[i];
    }
    return s;
}
```

### Static Linking

```bash
linux> gcc -Og -o prog main.c sum.c
linux> ./prog
```

GCC会调用一系列翻译器（预处理器`cpp`将`main.c`翻译为ASCII中间文件`main.i`，编译器`cc1`将`main.i`翻译为ASCII汇编语言文件`main.s`，汇编程序`as`将`main.s`翻译为目标文件`main.o`），得到`main.o`和`sum.o`。

链接器`ld`的作用就是将`.o`文件和一些必要的系统文件放在一起，链接起来并创建一个单个的可执行文件`prog`。

`.c`文件称为源文件，`.o`被分开编译，称为**relocatable object files可重定位目标文件**，而最后的可执行文件称为**Fully linked executable object file完全链接的可执行目标文件**。

#### 为什么分开编译最后链接？

- **Modularity模块化**
  这可以让代码分为更小的部分，而不是一个包含全部代码的文件，同时还可以定义函数库（C标准库、Math库）。

- **Efficiency效率**
  时间效率上，更改一个源文件只需要重新编译它而不需要重新编译其他源文件；空间效率上，可以将常用函数打包/聚合到一个文件中，实际编译并链接到程序中的是实际调用和函数

#### 链接器做了什么？

**Step1：Symbol resolution符号解析**

链接器会定义/引用**Symbol**（全局变量和函数），并（被汇编器）存储在 *Symbol table* 中。*Symbol table* 是一个struct的数组，每个结构体包含符号的名字、大小、所在位置。链接器会将每个符号引用与定义相关联。

**Step2：Relocation重定位**

- 将分离的代码段和数据段合并为单一段。

- 将符号从 `.o` 文件中的相对位置（函数地址为其在模块中的偏移量）重新定位到可执行文件中的最终绝对内存位置。

- 更新对这些符号的所有引用以反映它们的新位置。

More details：

#### 三种Object file（模块）

- **可重定位目标文件relocatable object file**（`.o`文件）
  汇编器的输出（不是二进制文件），不能以任何形式加载到内存中，实际使用前需要链接器对其操作。每个 `.o` 文件都由一个源文件（`.c` 文件）生成。

- **可执行目标文件executable object file**（`a.out`）
  包含代码和数据，格式允许直接复制到内存中并执行。

- **共享目标文件Shared object file**（`.so`文件）
  特殊类型的可重定位目标文件，可以加载到内存并动态链接，在加载时或运行时使用。在Windows中被称为 **Dynamic Link Libraries静态链接库**（DLLs）。

#### 可执行与可链接格式（ELF）

**ELF**（Executable and Linkable Format）是一种标准二进制文件格式，用于存储和表示程序的代码和数据。它提供了一种通用的格式，使用于上述的三种文件，无论是目标文件、可执行文件，还是共享库文件，它们都是 ELF 的子类型。**通用名称**：ELF 二进制文件。内部结构：

- **ELF header**（ELF头部）
  
  - 字长、字节序、文件类型（`.o`、`exec`、`.so`）、机器类型等。

- **Segment header table**（段头表）
  
  - 页大小、虚拟地址、内存段（sections，段）、段大小。

- `.text` section（代码段）
  
  - 存放代码。

- `.rodata` section（只读数据段）
  
  - 存放只读数据：如跳转表等。
  - 以上三部分都是**只读**

- `.data` section（数据段）
  
  - 存放已初始化的全局变量。

- `.bss` section（未初始化数据段）
  
  - 存放未初始化的全局变量。
  - **Block Started by Symbol**（符号开始的块）。
  - **Better Save Space**（更好地节省空间）。
  - 有段头，但实际不占用空间。

- `.symtab` section（符号表段）
  
  - 符号表。
  - 存放过程（函数）和静态变量的名称。
  - 段的名称与位置。

- `.rel.text` section（.text 段的重定位信息）
  
  - `.text section`的重定位信息。
  - 可执行文件中需要修改的指令地址。
  - 修改指令所需的信息。

- `.rel.data` section（.data 段的重定位信息）
  
  - `.data section`的重定位信息。
  - 合并后的可执行文件中需要修改的指针数据的地址。

- `.debug` section（调试段）
  
  - 保存符号调试信息（用于 `gcc -g` 选项）。
  - 即将源代码中行号与机器代码中行号相关联的信息。

- **Section header table**（段头表）
  
  - 每个段的偏移量和大小。

#### Linker Symbols

链接器有三种符号：

**Global symbols**（全局符号）

- 由模块 **`m`** 定义的，可被其他模块引用的符号。
- 例如：非 **static** 的 C 函数和非 **static** 的全局变量。

**External symbols**（外部符号）

- 由模块 **`m`** 引用但由其他模块定义的全局符号。

**Local symbols**（局部符号）

- 由模块 **`m`** 定义并仅供模块 **`m`** 引用的符号。
- 例如：用 **static** 属性定义的 C 函数和全局变量。（对其他程序可见的函数是没有 static 属性定义的。）
- 局部链接符号**不是**局部程序变量。

非static的C变量存储在栈上，而static变量存储在`.bss`或`.data`中，就像全局变量。如果同一变量名的static变量在不同的作用域中有了不同的值，链接器会为其分配不同的名字。

如果所有模块中有多个符号定义，我们将符号定义为强 或 弱：

- Strong：进程 or 函数名 or 初始化过的全局变量

- Weak：未初始化的全局变量

链接器有如下规则：

1. 不允许多个强符号。
   每个元素只能被定义 1 次，否则会链接错误

2. 存在一个强符号和多个弱符号时，总是选择强符号。
   弱符号的引用将关联到强符号

3. 如果有多个弱符号，将从中随机取值。
   可以通过`gcc -fno-comon`来覆写。编译器会将相同的弱符号存储在共享的内存块，可以重复定义；使用`gcc -fno-comon`后，将禁止这种共享行为，全局变量会直接存储到目标文件的**定义处**。

#### Linker Puzzles

两个强符号：Link time error:two strong symbols(p1)

如果两个弱符号类型相同，一般不会出现问题；但是当类型不同时，例如：

```c
// in a.c
int x; int y;
p1() {}
// in b.c
double x;
p2() {} 
```

当使用`b.c`中的`x`时，将**可能**会覆写`y`。Evil！

当我们将其中一个变成强符号，例如：

```c
// in a.c
int x = 5; int y = 7;
p1() {}
// in b.c
double x;
p2() {} 
```

那么将**一定**会覆写`y`。Nasty！

所以，尽可能避免全局变量。如果需要，尽可能使用`static`。定义时记得初始化。如果使用外部全局变量，用`extern`属性告诉编译器。

#### Relocation

在重定向中，链接器会将目标文件的所有代码放在每个模块的`.text`部分，并连续的存储在可执行文件的`.text`部分。可执行文件包含所有系统代码的模块定义的代码，并对`.data`做相同的事情。之后还有符号表`.symtab`和调试信息`.debug`。

但是编译器有时候并不知道这些函数/变量的存储地址，所以会在汇编代码中插入**重定向条目**，例如：

```c
int array[2] = {1, 2};
int main()
{
    int val = sum(array, 2);
    return val;
}
```

在汇编代码中就会插入 `0`  作为占位符，并通过重定向条目告诉编译器这里应该是什么：

```asm6502
0000000000000000 <main>:
   0:    48 83 ec 08              sub    $0x8,%rsp
   4:    be 02 00 00 00           mov    $0x2,%esi
                        a: R_X86_64_32 array
   9:    bf 00 00 00 00           mov    $0x0,%edi
                        f: R_X86_64_PC32 sum-0x4
   e:    e8 00 00 00 00           callq  13 <main+0x13>
  13:    48 83 c4 08              add    $0x8,%rsp
  17:    c3                       retq
```

如果我们将其编译为可执行文件后，再用`objdump`反编译它，那么引用处将会是准确的值而非占位符。

#### 加载可执行文件

可执行文件可以直接加载到内存中，`.init`，`.text`，`.rodata`将加载到只读代码段（Read-only code segment），而`.data`和`.bss`将被加载到可读写代码段（Read/write data segment）。

#### 打包

数学函数、输入输出、内存管理……为了提高效率和代码的可复用性，我们可以将这些代码打包为库函数，将API打包并提供给其他程序员。链接器有如下两种选择：

- 将所有代码放在单一文件
  优点：使用简单
  缺点：空间和时间使用效率低下，程序臃肿

- 每个函数放在单独的文件
  优点：效率更高，空间和时间使用效率更高
  缺点：增加了程序员的负担，文件的组织、管理、更新、维护复杂化

而我们最终要做到就是**权衡**，例如C++的标准库，将同一类函数放在一个文件内。

解决方案：

- 远古解决方法：**静态库Static libraries**（ `.a`的归档文件）：在使用时将需要的`.o`文件通过archive或AR的程序来捕获并将其打包为一个更大的文件，并生成一个内容目录。
  `libc.a`：C标准库，有1496个目标文件，约4.6MB；
  `libm.a`：C数学库，有444个目标文件，约2MB；

- 现代解决方案：**共享库Shared libraries**：相较于每个可执行文件都需要相应函数的副本，动态库/共享库允许提供一个机制，使该系统上允许的程序共用同一个函数的实例。
  也称动态链接库（Dynamic Link Libraries）DLLs，是`.so`文件。直到可执行文件加载到内存/执行时才会链接。

> 其实就是用debug模式编译出的可执行文件。将这种文件导出后直接运行，就会产生**动态链接库错误**。所以编译导出时应该用release模式静态编译，并将还缺失动态链接库复制一份副本放在可执行文件目录。

在C代码中，`include`会由C预处理器处理（还有`define`等，将其变成扩展版本），链接器将直接动态处理链接问题。

## Case study: Library interpositioning库打桩

**Library interpositioning库打桩/库函数拦截**：允许使用链接实际拦截如C标准库中函数的调用。

库打桩可以发生在：编译、链接、加载、运行等阶段，截获来自库函数的调用

### 安全

- **限制隔离(Confinement/Sandboxing)**：创建隔离的运行环境，限制程序对系统资源（如文件、网络、内存等）的未授权访问，增加额外的安全性，比如防止恶意代码对系统资源的破坏。

- **背景加密(Behind the scenes encryption)**：自动对某些数据进行加密和解密操作，而不需要修改现有代码，在进行敏感操作（如文件写入或网络传输）时，可以在拦截对应的API函数调用处，插入加密操作，使得数据始终是以加密形式存储或发送的。提高数据保护能力，降低数据泄露的风险。

### 调试

- 拦截函数调用时的参数和结果，能够帮助工程师快速定位隐藏的BUG，特别是那种依赖第三方库或协议的复杂问题。

### 监控Monitoring / 性能分析Profiling

- 统计函数调用次数。（函数的调用次数以及参数分析，有助于优化或调试高频调用。）

- 分析函数调用的具体位置（Call Sites）以及传递给函数的参数。

- Malloc跟踪：检测内存泄漏（内存未被正常释放）、生成地址轨迹（记录程序运行过程中发生的每一次内存分配、释放和地址访问）

（类似于断点调试，VS的调试界面相当于这一功能）

编译时，可以将`malloc`/`free`函数进行替换；

链接时，可以将其连接到有特殊名称的函数（把标准的 `malloc` 函数解析为 `__wrap_malloc`，把 `__real_malloc` 函数解析为原始系统的 `malloc`。）；

加载/运行时，通过动态链接实现函数拦截。自定义版本的 `malloc` 和 `free` 使用共享库（Shared Library）加载，并在运行时根据不同名称解析动态链接函数。
